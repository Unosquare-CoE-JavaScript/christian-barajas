# ANGULAR

## Modularization
- In Angular applñications, modules are small pieces of code with independent program functionalities.
- If you don't pay rapt attention to propert software architecture, parts of your app can become deeply entangled and disorganized, making it more difficult to reuse code or test any piece of code in isolation.
- Modules may enable you to: 
  - Develop a particular piece of functionality independently from the others
  - Manage teams more easily by enabling each development team to work on a separate feature
  - EExplicitly define the list of modules that the current one requires to function
  - Deploy features gradually
  - Build scalable application
  - Write test easily
  
### Types of modules in Angular
- **Root Module** - It's the main module in an Angular application. It is generated by the Angular CLI as AppModule and bootsrapped when the application starts. Every other Angular module depends either directly or indirectly on the root module. Only one root module can exist in an Angular application.
- **Core Module** - Usually contains components that are used once in an Angular application, such as a navigator bar, loader, footer, ect. This module should be loaded globally in AppModule.
- **Shared Module** - It's made up of directives, pipes, and components that can be reused in feature modules. A component that us reused in multiple modules of your Angular application
- **Feature Module** - It house the main features of your Angular application. Breaking certain functionalities into feature modules helps you split the application into dedicated areas. This enable multiple developers or teams of developers to work on independent features without breaking other parts of the applicaton.

### Registering components with a module
- To create a component and register it in a module at the same time, use the following Angular CLI command: 
  ```cmd
    ng g c Module/Component --module=Module
  ```

### Best Practices
1. Folder structure and code organization are subjective and depend on the app you are working on. This is only an inspiration for how you could structure your app.
  - Ex of main folders could be: 
    - Core - contains all the components which need to be available when the app starts. This includes the shell and the bottom menu. Also part of the core is the mini-player and the fullscreen player.
    - Shared - contains all the components which are shared between the views. 
    - Views - contains the views we can route to.
  - View Specific Components is one folder (type) I didn’t mention at the beginning. Some components are reused in different views, some are only used in one view. Keeping code as close as possible to where it is used is a good practice. Therefore we place components that are only used in one view into that view folder. 
2. There are 3 strategies I want to have a closer look at today:
  - Everything in one module
  - One module per feature / view (Lazy Load) - We get the optimal bundle size when we load all the view lazy. Since the shared module is used in multiple lazy loaded modules, it gets loaded in a separate common module. This pattern is somewhere in the middle of the two other approaches. We get small bundle sizes with little boilerplate and we still have a clear structure. If your application is larger you can also split the modules again into smaller feature modules or bundle views together into bigger feature bundles. This can either help you organize your code or lead to confusion on when to create those sub-modules.
  - One module per component (SCAM) - In this strategy, we create a single module for every component. SCAM is an abbreviation for “Single Component Angular Module”. Each component module only imports the modules it directly uses. That means if we remove a component we also remove all its dependencies automatically. Another benefit of this approach is that Angular can build the optimal bundles for lazy loaded routes thanks to the clear dependency tree.
- How to decide what pattern to use? - o decide between the view/feature module and the single component module you have to ask yourself:
  `How much boilerplate are you willing to add for a clear dependency tree and a simple rule to follow?`


## Dependecy Injection
-  Dependency injection, or DI, is a design pattern in which a class requests dependencies from external sources rather than creating them.
- Known to be a programming paradigm, dependency injection is what makes a class independent of its dependencies. Dependency injection enables the creation of dependent objects outside of a class while providing those very objects to a class in numerous ways. 
- Angular's DI framework provides dependencies to a class upon instantiation. Use Angular DI to increase flexibility and modularity in your applications.
- The @Injectable() decorator specifies that Angular can use this class in the DI system. The metadata, providedIn: 'root', means that the HeroService is visible throughout the application.

### Injecting services
- Injecting services lets a component access their features and data.
- To inject a dependency in a component's constructor(), supply a constructor argument with the dependency type. 
- When a service depends on another service, follow the same pattern as injecting into a component. 

### Types of Dependency Injection
- There are 3 types of DI in Angular: 
  1. Constructor injection: Here, it provides the dependencies through a class constructor.
  2. Setter injection: The cliente uses a setter method into which he injector injects the dependency.
  3. Interface injection: The dependency provide and injector method that will inject the dependency into any client passed to it. On the other hand the clients must implement an interface that exposes a setter method that accepts the dependency.

### Advantages of Dependency Injection
- Offers some incredible advantages:
  - DI helps in Unit Testing.
  - Boilerplate code is reduced, as intializing of dependencies is done by the injector component.
  - Extending the application becomes more manageable.
  - It helps to enable loose coupling, which is essential in application programming.

### DI As a Design Pattern
- It's a coding pattern where a class receives its dependencies from an external source rater than creating them itself.

## Angular Lifecycle
- A component instance in Angular has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views. 
- The lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed. 
- The lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM.
- Angular calls these hook methods in the following order:
  1. ngOnChanges: When an input/output binding value changes.
  2. ngOnInit: After the first ngOnChanges.
  3. ngDoCheck: Developer's custom change detection.
  4. ngAfterContentInit: After component content initialized.
  5. ngAfterContentChecked: After every check of component content.
  6. ngAfterViewInit: After a component's views are initialized.
  7. ngAfterViewChecked: After every check of a component's views.ngOnDestroy: Just before the component/directive is destroyed.
  8. ngOnDestroy.
- Directives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution.
- But what is the advantage of the ngOnInit hook if the same work could be done on the component’s constructor()? Well, let's go into it: 
  - The constructor()
    1. The default method of the class is executed when the class is instantiated and ensures proper initialization of fields in the class and its subclasses.
    2. Dependency Injector (DI) in Angular, analyses the constructor parameters and when it creates a new instance by calling new MyClass() it tries to find providers that match the types of the constructor parameters, resolves them, and passes them to the constructor like new MyClass(someArg)
    3. Should only be used to initialize class members but shouldn't do actual work. This is because the constructor is called before ngOnInit, at this point the component hasn’t been created yet, only the component class has been instantiated thus the dependencies are brought in, but the initialization code will not run.
  - The ngOnInit()
    1. Is a life cycle hook called by Angular to indicate that Angular is done creating the component.
    2. Should be used for all the initialization/declaration. Because at this point the component will be initialized.
- ngDoCheck - This hook can be interpreted as an “extension” of ngOnChanges. You can use this method to detect changes that Angular can’t or won’t detect. It is called in every change detection, immediately after the ngOnChanges and ngOnInit hooks.
- ngAfterContentInit - This method is called only once during the component’s lifecycle, after the first ngDoCheck. 
- ngAfterContentChecked - This method is called once during the component’s lifecycle after ngAfterContentInit and then after every subsequent ngDoCheck.
- ngAfterViewInit - This method is called only once during the component’s lifecycle, after ngAfterContentChecked. 
- ngAfterViewChecked - This method is called once after ngAfterViewInit and then after every subsequent ngAfterContentChecked. 

## Best Practices
- Use ngFor with TrackBy - When you change an array, the complete DOM tree re-renders, which is not performance-wise. To solve this, you must use ngFor with trackBy, which uniquely identifies each DOM element and enables Angular to re-render only the modified elemen

## Data binding
- Deals with how to bind your data from component to HTML DOM elements (Templates). With this, we can easily interact with application without worrying about how to insert your data.
- We can make connections in two different ways one way and two way binding.

### One-way data binding
- It's a one-way interaction between component and its template. If you perfomr any changes in your component, then it will reflect the HTML elements. it supports the following types:
  - String interpolation, it's the process of formatting or manipulating strings. In Angular, Interpolation is used to display data from component to view (DOM). It is denoted by the expression of `{{}}` and also known as mustache syntax.
  - Event Binding, events like mouse click, double click, hover or any keyboard and mouse actions. if a user interacts with an application and performs some actions, then event will be raised. It is denoted by either parenthesis () or `on-`. We have different ways to bind an event to DOM element. 
  - Property Binding, It's used to bind the data from property of a component to DOM elements. it is denoted by `[]`.
  - Attribute binding, it's used to bind the data from component to HTML attributes. The syntax is as follows `<HTMLTag [attr.ATTR]="ComponentData"></HTMLTag>`.
  - Class binding, it's used to bind the data from component to HTML class property. The syntax is as follows `<HTMLTag [class]="dynamicClass"></HTMLTag>`.
  - Style binding, it's used to bind the data from component into HTML stlye property. The syntax is as follows `<HTMLTag [style.color]="StyleColorParameter"></HTMLTag>`.

### Two-wy data binding
- It's a two-way interaction, data flows in both ways (from component to views and views to component). An example would be ngModel. If you do any changes in your property (or model) then, it reflects in your view and vice versa. it is the combination of property and event binding.
  - NgModel, it's a standalone directive, ngModel directive binds form control to property and property to form control. The syntax of ngModel is as follows `<input [(ngModel)]="model.name"/>`.


## Anti Patterns
- Here are some anti-pattern that is a common mistake of component developers around inputs:
  1. In traditional jQuery widgets it was very common to have a master options object and as we start developing components in Angular we should avoid this pattern. When we use global option objects like this it makes it hard to support two-way binding and have a intuitive API.
    - Rather than having a global options object we declare individual inputs for each option. This will allow us to:
      - Use better change detection strategies such as OnPush
      - Make our component more reactive
      - Support two-way binding syntax


## RxJS Antipatterns
1. STATEFUL STREAMS - Store results outside of our main stream, At every step of the pipeline we are relying on state that is keept outside of our stream. This can introduce side-effects and we cannot argue about our data flow easily, as we cannot know at what point in time which property will be updated, thus making our stream rely on state.
  - If one of the requests fails, then our state will go out of sync and maybe even produce erroneous results. In order to prevent this, proper error handling becomes a hassle, as we have to handle every request separately and perform the appropriate cleanup.
  - We now want to introduce a way to model our streams that alleviates the need to store results outside of the stream and rather carry them along through our pipeline.
2. State Duplication - When state is duplicated, the app loses its single source of truth. A single source of truth is important because it is the one place all code can look to find the most accurate information.
  - One of the most common code duplication pitfalls comes from using a collection of objects and storing off separate properties regarding single entities in that collection or properties of that collection.
  - For example, if the code requires a selected entity for updating, the impulse may be to store off the entire entity in a “selectedEntity” property. Once the entire entity is stored in the “selectedEntity” property, that data has been duplicated in the state object. This is called “Direct Entity Duplication”.
  - The solution is to store a reference to the entity in the collection and pull all details for that entity directly from the collection. This way all updates to that entity can be accurately reflected across the entire application.
3. FRANKENSTATE - When an application relies on more than one solution to manage state and it lacks clear boundaries between what data is managed where, it is easy to end up with a state management solution that is riddled with state duplications and data inconsistencies. 
  - This type of solution, which I call “FrankenState”, is difficult to develop against because of the confusing structure of the state object and the lack of a single source of truth.
  - Frankenstate can be exacerbated by teams independently using different solutions for state management that have overlapping data managed by each solution.
  - Should the need to change solutions arise, developers should ask themselves three questions:
    I. What does this new solution do that my old solution cannot?
    II. What are the boundaries for what this solution will do?
    III. Will this solution replace the existing solution, and if not what is the strategy for how to approach shared data?
  - When planning for a new application, teams should ask:
    I. What is the main need for shared data in this application?
    II. Are there libraries or methods that handle this sort of problem better than others?
    III.What is my team familiar with and what is our capacity to learn/maintain a new solution?
4. Failure to unsubscribe - When an observable is subscribed to, it will remain open until the stream completes or the observable is unsuscribed. Failing to unsubscribe from an observable when a component is destroyed will leave that subscription open. This leads to memory leaks in the aplication.
  - Always unsubscribe. Luckily there are several different ways to unsubscribe from an observable. The most efficient solution is to take advantage of Angular’s async pipe in the component template. 
  - The async pipe handles subscribing on ngOnInit and unsubscribing on ngOnDestroy. It pushes change detection down into the template layer, and reduces a significant amount of code within the components which leads to easier testing and more code clarity. 
5. Nested Subscriptions -  The problem with nesting subscriptions is that the first subscription has no control over the nested subscriptions. One very common result of this anti-pattern is that it sets up a race condition between the first subscription and the nested subscriptions which can lead to mismatched data between entities.
  - Using pipeable operators means the outer observable manages the inner observable, including subscribes and unsubscribes. The main benefit of managing subscriptions in this manner is since the outer observable manages the inner observable, there is no possibility of mismatched data. 
  - This protects against mismatched data and removes the race condition created by nesting subscribes inside other subscribes.
6. SHARING REDUX ACTIONS - When more than one component or service is capable of dispatching the same action and there is an unexpected dispatch of this action, it becomes a “Whodunit” mystery that can be difficult to solve.
  - Shift our thinking to an event-driven style of programming, we then start to understand how to create unique actions that describe the event that has happened and react to that event instead of simply issuing commands. So a single action called “loadUser” can become several actions that result in the loading of the user but clearly defines the event that led up to this action. 
7. BROAD SELECTORS - Change detection in Angular is basically triggered by reference. Any time a new reference is handed down to a component, that component will rerender. While this is desirable for keeping the data displayed by an application up-to-date with the latest values, unnecessary rerenders can significantly slow down performance.
  - By creating broad selectors that return large amounts of unnecessary state data, the odds that the component will experience unnecessary rerenders goes up. State management solutions like NgRx that offer memoized selectors can dramatically reduce the number of unnecessary component rerenders when used efficiently.
  - use composed selectors to return only the data required by the component. In addition to reducing the number of rerenders, composed selectors also reduce the amount of code inside of the component because the component no longer needs to have knowledge of the entire state object to be able to grab the values it cares about. Another beneficial side-effect is that there are less tests to write inside the component. 
8. MONOLITHIC NGRX EFFECTS - The problem with a monolithic effect is that the code can become so convoluted that it is difficult to read, difficult to test, and difficult to onboard new developers.
  - Monolithic effects are a common side effect of assuming that one action must trigger and complete all of the work it is meant to do inside one effect.
  - Break up the effect into smaller units of work that result in the dispatch of a new action that triggers the next effect to complete the next unit of work. 

## Circular Dependencies
- In software engineering, a circular dependency is a relation between two or more modules which either directly or indirectly depend on each other to function properly. Such modules are also known as mutually recursive.
- In a small program like this, it’s not a big problem to detect circular dependency. But in a large codebase, once we depend on a wrong module accidentally, then it’s tough to detect this later on. So today we are gonna use a tool call madge. Let’s see how we are gonna use it. `execute npx madge --extensions js,ts --circular .`
- Part of the issue is that Angular has it's own NGModule System which runs differently than the Es6 Module system. Here are some tips for this:
1. In ES6 Modules (in our functions that need references to Angular components), this style fails
  - Where @name is pseudonym for a file location where the component folder is located. This type of impor imples an index.ts file listing all the componentes in that folder. To fix the problem:
  ```typescript
    import { comp1, comp2} from "@name/components";

    // Specify explicit file paths instead
    import { comp1} from "@name/components/comp1";
    import { comp2} from "@name/components/comp2";
  ``` 
2. Improper ES6 import references - Assuming the statement below is in an ES6 module, with an index.ts file, this appears to cause the error.
  ```typescript
    import {something} from "."
    //do this instead
    import {something} from "./moduleName"
  ```
  - The more explicit form indicates that we directly want to grab something from moduleName. Finally keep the imports segregated:
    ```typescript
    import { a, b, c} from "AModule";
    import { d, e, f} from "BModule"
    import { g, h, i} from "CModule"
    //rather than 
    import {a,b,c,d,e,g,h,1} from "@name/functions";
    //where functions folder contains an index file.
  ```


## Unit. End-to-End & Integration Testing
- It's a testing individual components of the applications, It is performed by using Karma and Jasmine.
- Jasmine is used to writing the tests and Karma is used in running those tests. We can use Async and TestBed in testing Asynchronous Code, Components, Directives and Service easier.
- Integration Testing is used to testing a component with templates and this testing containing more time as per comparison Unit Test.
- E2E is used to testing the entire application looks like
  - All User Interactions
  - All Service Calls
  - Authentication/Authorization of app
  - Everthing in the App.
- Unit testing and Integrations testing will do as fake calls but E2" testing is done with your actual services and APIs Calls.

### Diference between unit, integration and e2e tests
- Unit Tests sits at the base of the Testing Pyramid. This means they take lesser time to code and classes that you are testing should be more isolated. When you try to test Networking functions, you should use Mock Response to test for both positive and negative response.
- Integration Test sits at the next level after Unit test. Here, you will use Real Network Responses by hitting the real server endpoint, and test that the small units you have written are able to work together.
- UI Testing automates repetitive tasks to ensure that your most critical UI interactions keep working as you're adding new features or refactoring your app's codebase.
- E2E should test the user journeys of the app by using Real Network Response by hitting the Real server endpoints.
- In summary: 
  - End to end: A helper robot that behaves like a user to click around the app and verify that it functions correctly. Sometimes called "functiona testing" or e2e.
  - Integration: Verify that several units work together in harmony.
  - Unit: Verify that individual, isolates parts work as expected.
  - Static: Catch typos and type errors as you write the code.

### Triple Rule of Testing
1. Arrange - Create and intialize the Components.
2. Act - Invoke the Methods/Functions of Components.
3. Assert - Assert the expected outcome/behaviour.

### Best Practices
- Use BeforeEach to initialize the context for your tests.
- Make sure the string descriptions you put in describe() or it() make sense as outputs.
- Use after() and afterEach() to clean-up your test if there is any state that may bleed over.
- If any one test is over 15 lines of code, you may need to refactor the test.


### What is Karma? What is use in Angular?
- Karma is a tool for executing source code against test code inside a browser environment.
- It supports the running of test in each browser it's configured for. 
- Also whatches the files and can trigger a test rerun whenever a file changes. 
- All configurable data can be found in the root karma.config in the root of the Angular project.

### Jasmine
- It's used as a testing tool for unit testing and is one of the most significant types of Automated Testing. It also comes to the web apps, in testing our plans consisting end-to-end testing, load, and user interface testing.
- The describe(string, function) - function defines what we call a Test Suite, a collection of individual Test Specs.
- The it(string, function) - defines an individual Test Spec, this contains one or more Test Expectations.
- the matcher(expected) - it's a expression that we call a MAtcher, it does a boolean comparasion with the expected value passe din vs. the actual value to the expect function, if they are false the spec fails.
- Types of matchers used in Jasmine: 
  - toBe()
  - toContain()
  - toBeArray()
  - tobeFalse()
  - toBeThruty()
  - toBeOddNumber()
  - tobeEmptyObject()
- Asymmetric Matchers in Jasmine: 
  - jasmine.any
  - jasmine.anything
  - jasmine.arrayContaining
  - jasmine.objectContaining
  - jasmine.stringMatching
- Disable tests in Jasmine with xdescribe or xit
- We can change the return value of a method by using `authService.currentUser.and.returnValue({ /** DATA **/});`
- Setup and teardown
  - beforeAll - This function is called once, before all the specs in describe test suite are run.
  - afterAll - This function is called after all the specs in a test suite are finished.
  - beforeEach - This function is called before each test specification, it function has been run.
  - afterEach - This function is called after each test specified has been run.

### Headless Browser
- It is used in provindg compterized control of a web page in a popular web browser and is performed through CLI or in managing network communication. 
- It is also used for examining web pages as it renders and understands HTML and consists of components like Page Layout, Color, Font Selection and in executing JS and AJAX.

### Spy
- Jasmine Spy allows in spying on our application functions. There are two types of spy technologies
  - spyOn() - helps by allowing us to spy on a specific piece of code.
  - createSpy - helps by allowing us to spy on the functionality.

### Inject a mock service in a unit test
1. Via TestBed, The TestBed acts as a dummy Angular Module and we can configure it like one including with a set of providers like so:
  ```javascript 
    TestBed.configureTestingModule({providers: [MyCustomService]})

    // We can then ask the TestBed to resolve a token into a dependency 
    // using it's internal injector
    let customService = TestBed.get(MyCustomService):

    // If most of our test specs need the same dependency mocked the same way
    // we can resolve it once in the beforeEach function and mock it it there.
  ```
2. Via inject function, the inject function wraps the test spec function but lets us also inject dependencies using the paren injecto in the TestBed:
  ```javascript
    it('Should do something', inject([CustomService], (injectedService: CustomService) => {
      expect(injectedService).toBe(customService);
    }))
  ```
  -  Using the inject function: 
    - Makes it clear what dependencies each spec function uses.
    - if each test spec requires different mocks and spys this is a better solution that resolving it once per test suite.
3. Overriding the component providers, Before we create a component via the TestBed we can override it's providers. Like so:
  ```javascript
    TestBed.overrideComponent(
      LoginComponent, 
      {
        set: {
          providers: [{provide: CustomService, useClass: MockCustomService}]
        }
      }
    )
  ```
  - The syntax is pretty specific, it's called a MetaDataOverride and it can have the properties set, add and remove. We use set to completely replace the providers array with the values we've set.
4. Via the component injector
  - When the component is created since it has it's own injector it will resolve the CustomService itself and not forward the request ot it's parent TestBed injector.
  - If we wanted to get the same instance of dependency tht was passed to the component constructor we need to resolve using the component injector, we can do that through the component fixture like so:
  ```javascript
    componentService = fixture.debugElement.injector.get(CustomService);
  ```


### Protactor
- It's an end-to-end test framework for Angular, It runs your test inside a real browser, interacting with it as real person would. 
- Unlike unit test, where we test individiual functions, here we test the entire logic.
- Protactor is able to fill in forms, click buttons and confirm that the expected data and styling s displayed in the HTML document.
- Just like Karma Protractor has its own configuration file called protractor.conf located at the root of your Angular project.


### Testing @Inputs & @Outputs
- We can test inputs bt just setting values on a components input properties. We can test outputs by subscribing to an EventEmitters observable and storing the emitted values on local variables.
- To test inputs we need to do things:
  - We need to be able to change the input property enabled on our component.
  - We need to check that the button is enabled or disabled depending on the value of our input property.
  ```javascript
    it('Should do', () => {
      component.enabled = false;
      fixture.detectChanges();
      expect(something).toBeTruthy();
    })
  ```
- Since the output event is actually an Observable we can subscribe to it and get a callback for every item emitted. We store the emitted value to a user object and then add some expectations on the user object.
- To test outputs we need to do the following: 
  - Setup data in our input controls.
  - Trigger a click on our submit button, thus synchronously emits the user object in the subscribe callback.
  ```javascript
    it('Should do', () => {
      const value = 
      component.onChange.subscribe((newValue) => value = newValue);

      element.triggerEventHandler('click', null);

      expect(value).toBe('Value changed');
    })
  ```

### Code Coverage
- The CLI can run unit test and create code coverage reports. They show you any parts of our code base that may not be properly tested by your unit tests.
- The code coverage percentages ley you estimate how much of your code is tested. If your team decides on a set minimum amount to be unit tested.

### Mocka and Chai
- Mocha js a JS test framework running on NodeJS and in the browser. Allows async testing, test coverage reports and use of any assertion library. It gives a Suite for describing, running and building test but it does not give us a way to check values.
- Chai is a BDD/TDD Assertion library for NodeJS and the browser that can be delightfully pared with any JS testing framework.
- Basically, mocha is a framwork and chai is a library.
- Mocha uses hooks to organize its structure:
  - describe(): It's used to group, which you can nest as deep;
  - it(): It's the test case;
  - before(): It's a hook to run before the first it() or describe().
  - beforeEach(): It's a hook to run before each it() or describe().
  - after(): It's a hook to run after it() and describe().
  - afterEach(): It's a hook to run after each it() or describe();

## Directives
- They are DOM elements to interact with your application. Generally, directive is a TypeScript function. When this function executes Angular compiler checked it inside DOM element. Angular directives begin with ng- where ng stands for Angular and extends HTML tags with @directive decorator.
- Attribute directives - Used to add new attributes for the existing HTML elements to change its look and behaviour.
- Structural directives - Used to add or remove DOM elements in the current HTML document.

### Component based directives
- Component can be used as directives. Every component has Input and Output option to pass between component and its parent HTML elements.

### Structural directives
- They Change the structure of DOM by adding or removing elements. It is denoted by * sign with three pre-defined directives NgIf, NgFor and NgSwitch. Let’s understand one by one in brief.
  - **NgIf** - it is used to display or hide data in your application based on the condition becomes true or false. We can add this to any tag in your template.
  - **ngIfElse** - it is similar to ngIf except, it provides option to render content during failure scenario as well.
  - **ngFor** - it is used to repeat a portion of elements from the list of items.
  - **trackBy** - Sometimes, ngFor performance is low with large lists. For example, when adding new item or remove any item in the list may trigger several DOM manipulations. To iterate over large objects collection, we use trackBy. It is used to track when elements are added or removed. It is performed by trackBy method. It has two arguments index and element. Index is used to identity each element uniquely. Simple example is defined below.
  - **NgSwitch** - It is used to check multiple conditions and keep the DOM structure as simple and easy to understand.

### Attribute directives
- Attribute directives performs the appearance or behavior of DOM elements or components. Some of the examples are NgStyle, NgClass and NgModel. Whereas, NgModel is two-way attribute data binding explained in previous chapter.
  - ngStyle - It is used to add dynamic styles. Below example is used to apply blue color to the paragraph.
  - ngClass - It is used to add or remove CSS classes in HTML elements.

### ng-template
- It is used to create dynamic and reusable templates. It is a virtual element. If you compile your code with ng-template then is converted as comment in DOM.

# Pending Stuff
- How to share data between componentes:
  - Decorators(ViewChild, Input, EventEmitter)
- Ui/UX Libraries, responsive design
- Pipes
- Angular Routing